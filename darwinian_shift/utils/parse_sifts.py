#!/usr/bin/env python
# -*- coding: utf-8 -*-

# File taken from https://github.com/mgalardini/pdb2uniprot
#
# Generated Thu Nov 20 17:12:58 2014 by generateDS.py version 2.13a.
#
# Command line options:
#   ('-f', '')
#   ('-o', 'sifts.py')
#
# Command line arguments:
#   eFamily.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -f -o "sifts.py" eFamily.xsd
#
# Current working directory (os.getcwd()):
#   src
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class entry(GeneratedsSuper):
    """The entry represents a database entry. This schema is currently
    designed for domain and mapping entires."""
    subclass = None
    superclass = None
    def __init__(self, dbEvidence=None, dbEntryVersion=None, dbVersion=None, dbAccessionId=None, dbSource=None, date=None, dbCoordSys=None, RDF=None, listDB=None, entryDetail=None, entity=None, alignment=None):
        self.original_tagname_ = None
        self.dbEvidence = _cast(None, dbEvidence)
        if isinstance(dbEntryVersion, str):
            initvalue_ = datetime_.datetime.strptime(dbEntryVersion, '%Y-%m-%d').date()
        else:
            initvalue_ = dbEntryVersion
        self.dbEntryVersion = initvalue_
        self.dbVersion = _cast(None, dbVersion)
        self.dbAccessionId = _cast(None, dbAccessionId)
        self.dbSource = _cast(None, dbSource)
        if isinstance(date, str):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%d').date()
        else:
            initvalue_ = date
        self.date = initvalue_
        self.dbCoordSys = _cast(None, dbCoordSys)
        self.RDF = RDF
        self.listDB = listDB
        if entryDetail is None:
            self.entryDetail = []
        else:
            self.entryDetail = entryDetail
        if entity is None:
            self.entity = []
        else:
            self.entity = entity
        if alignment is None:
            self.alignment = []
        else:
            self.alignment = alignment
    def factory(*args_, **kwargs_):
        if entry.subclass:
            return entry.subclass(*args_, **kwargs_)
        else:
            return entry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RDF(self): return self.RDF
    def set_RDF(self, RDF): self.RDF = RDF
    def get_listDB(self): return self.listDB
    def set_listDB(self, listDB): self.listDB = listDB
    def get_entryDetail(self): return self.entryDetail
    def set_entryDetail(self, entryDetail): self.entryDetail = entryDetail
    def add_entryDetail(self, value): self.entryDetail.append(value)
    def insert_entryDetail_at(self, index, value): self.entryDetail.insert(index, value)
    def replace_entryDetail_at(self, index, value): self.entryDetail[index] = value
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def add_entity(self, value): self.entity.append(value)
    def insert_entity_at(self, index, value): self.entity.insert(index, value)
    def replace_entity_at(self, index, value): self.entity[index] = value
    def get_alignment(self): return self.alignment
    def set_alignment(self, alignment): self.alignment = alignment
    def add_alignment(self, value): self.alignment.append(value)
    def insert_alignment_at(self, index, value): self.alignment.insert(index, value)
    def replace_alignment_at(self, index, value): self.alignment[index] = value
    def get_dbEvidence(self): return self.dbEvidence
    def set_dbEvidence(self, dbEvidence): self.dbEvidence = dbEvidence
    def get_dbEntryVersion(self): return self.dbEntryVersion
    def set_dbEntryVersion(self, dbEntryVersion): self.dbEntryVersion = dbEntryVersion
    def get_dbVersion(self): return self.dbVersion
    def set_dbVersion(self, dbVersion): self.dbVersion = dbVersion
    def get_dbAccessionId(self): return self.dbAccessionId
    def set_dbAccessionId(self, dbAccessionId): self.dbAccessionId = dbAccessionId
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_dbCoordSys(self): return self.dbCoordSys
    def set_dbCoordSys(self, dbCoordSys): self.dbCoordSys = dbCoordSys
    def hasContent_(self):
        if (
            self.RDF is not None or
            self.listDB is not None or
            self.entryDetail or
            self.entity or
            self.alignment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entry', namespacedef_=' xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='entry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entry'):
        if self.dbEvidence is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            outfile.write(' dbEvidence=%s' % (self.gds_format_string(quote_attrib(self.dbEvidence).encode(ExternalEncoding), input_name='dbEvidence'), ))
        if self.dbEntryVersion is not None and 'dbEntryVersion' not in already_processed:
            already_processed.add('dbEntryVersion')
            outfile.write(' dbEntryVersion="%s"' % self.gds_format_date(self.dbEntryVersion, input_name='dbEntryVersion'))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            outfile.write(' dbVersion=%s' % (self.gds_format_string(quote_attrib(self.dbVersion).encode(ExternalEncoding), input_name='dbVersion'), ))
        if self.dbAccessionId is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            outfile.write(' dbAccessionId=%s' % (self.gds_format_string(quote_attrib(self.dbAccessionId).encode(ExternalEncoding), input_name='dbAccessionId'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date="%s"' % self.gds_format_date(self.date, input_name='date'))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            outfile.write(' dbCoordSys=%s' % (self.gds_format_string(quote_attrib(self.dbCoordSys).encode(ExternalEncoding), input_name='dbCoordSys'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='entry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RDF is not None:
            self.RDF.export(outfile, level, namespace_='rdf:', name_='RDF', pretty_print=pretty_print)
        if self.listDB is not None:
            self.listDB.export(outfile, level, namespace_, name_='listDB', pretty_print=pretty_print)
        for entryDetail_ in self.entryDetail:
            entryDetail_.export(outfile, level, namespace_, name_='entryDetail', pretty_print=pretty_print)
        for entity_ in self.entity:
            entity_.export(outfile, level, namespace_, name_='entity', pretty_print=pretty_print)
        for alignment_ in self.alignment:
            alignment_.export(outfile, level, namespace_, name_='alignment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='entry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dbEvidence is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            showIndent(outfile, level)
            outfile.write('dbEvidence="%s",\n' % (self.dbEvidence,))
        if self.dbEntryVersion is not None and 'dbEntryVersion' not in already_processed:
            already_processed.add('dbEntryVersion')
            showIndent(outfile, level)
            outfile.write('dbEntryVersion=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.dbEntryVersion, input_name='dbEntryVersion'))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            showIndent(outfile, level)
            outfile.write('dbVersion="%s",\n' % (self.dbVersion,))
        if self.dbAccessionId is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            showIndent(outfile, level)
            outfile.write('dbAccessionId="%s",\n' % (self.dbAccessionId,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            showIndent(outfile, level)
            outfile.write('date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.date, input_name='date'))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            showIndent(outfile, level)
            outfile.write('dbCoordSys="%s",\n' % (self.dbCoordSys,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RDF is not None:
            showIndent(outfile, level)
            outfile.write('RDF=model_.RDF(\n')
            self.RDF.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.listDB is not None:
            showIndent(outfile, level)
            outfile.write('listDB=model_.listDBType(\n')
            self.listDB.exportLiteral(outfile, level, name_='listDB')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('entryDetail=[\n')
        level += 1
        for entryDetail_ in self.entryDetail:
            showIndent(outfile, level)
            outfile.write('model_.entryDetailType(\n')
            entryDetail_.exportLiteral(outfile, level, name_='entryDetailType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('entity=[\n')
        level += 1
        for entity_ in self.entity:
            showIndent(outfile, level)
            outfile.write('model_.entityType1(\n')
            entity_.exportLiteral(outfile, level, name_='entityType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('alignment=[\n')
        level += 1
        for alignment_ in self.alignment:
            showIndent(outfile, level)
            outfile.write('model_.alignment(\n')
            alignment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dbEvidence', node)
        if value is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            self.dbEvidence = value
        value = find_attr_value_('dbEntryVersion', node)
        if value is not None and 'dbEntryVersion' not in already_processed:
            already_processed.add('dbEntryVersion')
            try:
                self.dbEntryVersion = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (dbEntryVersion): %s' % exp)
        value = find_attr_value_('dbVersion', node)
        if value is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            self.dbVersion = value
        value = find_attr_value_('dbAccessionId', node)
        if value is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            self.dbAccessionId = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            try:
                self.date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (date): %s' % exp)
        value = find_attr_value_('dbCoordSys', node)
        if value is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            self.dbCoordSys = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RDF':
            obj_ = RDF.factory()
            obj_.build(child_)
            self.RDF = obj_
            obj_.original_tagname_ = 'RDF'
        elif nodeName_ == 'listDB':
            obj_ = listDBType.factory()
            obj_.build(child_)
            self.listDB = obj_
            obj_.original_tagname_ = 'listDB'
        elif nodeName_ == 'entryDetail':
            obj_ = entryDetailType.factory()
            obj_.build(child_)
            self.entryDetail.append(obj_)
            obj_.original_tagname_ = 'entryDetail'
        elif nodeName_ == 'entity':
            obj_ = entityType1.factory()
            obj_.build(child_)
            self.entity.append(obj_)
            obj_.original_tagname_ = 'entity'
        elif nodeName_ == 'alignment':
            obj_ = alignment.factory()
            obj_.build(child_)
            self.alignment.append(obj_)
            obj_.original_tagname_ = 'alignment'
# end class entry


class alignment(GeneratedsSuper):
    """This section of the schema deals with alignments. The alignment can
    be either a sequence alignment or a structural alignment."""
    subclass = None
    superclass = None
    def __init__(self, alignType=None, alignObject=None, score=None, block=None, geo3d=None):
        self.original_tagname_ = None
        self.alignType = _cast(None, alignType)
        if alignObject is None:
            self.alignObject = []
        else:
            self.alignObject = alignObject
        if score is None:
            self.score = []
        else:
            self.score = score
        if block is None:
            self.block = []
        else:
            self.block = block
        if geo3d is None:
            self.geo3d = []
        else:
            self.geo3d = geo3d
    def factory(*args_, **kwargs_):
        if alignment.subclass:
            return alignment.subclass(*args_, **kwargs_)
        else:
            return alignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alignObject(self): return self.alignObject
    def set_alignObject(self, alignObject): self.alignObject = alignObject
    def add_alignObject(self, value): self.alignObject.append(value)
    def insert_alignObject_at(self, index, value): self.alignObject.insert(index, value)
    def replace_alignObject_at(self, index, value): self.alignObject[index] = value
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def add_score(self, value): self.score.append(value)
    def insert_score_at(self, index, value): self.score.insert(index, value)
    def replace_score_at(self, index, value): self.score[index] = value
    def get_block(self): return self.block
    def set_block(self, block): self.block = block
    def add_block(self, value): self.block.append(value)
    def insert_block_at(self, index, value): self.block.insert(index, value)
    def replace_block_at(self, index, value): self.block[index] = value
    def get_geo3d(self): return self.geo3d
    def set_geo3d(self, geo3d): self.geo3d = geo3d
    def add_geo3d(self, value): self.geo3d.append(value)
    def insert_geo3d_at(self, index, value): self.geo3d.insert(index, value)
    def replace_geo3d_at(self, index, value): self.geo3d[index] = value
    def get_alignType(self): return self.alignType
    def set_alignType(self, alignType): self.alignType = alignType
    def hasContent_(self):
        if (
            self.alignObject or
            self.score or
            self.block or
            self.geo3d
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alignment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alignment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alignment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alignment'):
        if self.alignType is not None and 'alignType' not in already_processed:
            already_processed.add('alignType')
            outfile.write(' alignType=%s' % (self.gds_format_string(quote_attrib(self.alignType).encode(ExternalEncoding), input_name='alignType'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='alignment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alignObject_ in self.alignObject:
            alignObject_.export(outfile, level, namespace_, name_='alignObject', pretty_print=pretty_print)
        for score_ in self.score:
            score_.export(outfile, level, namespace_, name_='score', pretty_print=pretty_print)
        for block_ in self.block:
            block_.export(outfile, level, namespace_, name_='block', pretty_print=pretty_print)
        for geo3d_ in self.geo3d:
            geo3d_.export(outfile, level, namespace_, name_='geo3d', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='alignment'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.alignType is not None and 'alignType' not in already_processed:
            already_processed.add('alignType')
            showIndent(outfile, level)
            outfile.write('alignType="%s",\n' % (self.alignType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('alignObject=[\n')
        level += 1
        for alignObject_ in self.alignObject:
            showIndent(outfile, level)
            outfile.write('model_.alignObjectType(\n')
            alignObject_.exportLiteral(outfile, level, name_='alignObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('score=[\n')
        level += 1
        for score_ in self.score:
            showIndent(outfile, level)
            outfile.write('model_.scoreType(\n')
            score_.exportLiteral(outfile, level, name_='scoreType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('block=[\n')
        level += 1
        for block_ in self.block:
            showIndent(outfile, level)
            outfile.write('model_.blockType(\n')
            block_.exportLiteral(outfile, level, name_='blockType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('geo3d=[\n')
        level += 1
        for geo3d_ in self.geo3d:
            showIndent(outfile, level)
            outfile.write('model_.geo3dType(\n')
            geo3d_.exportLiteral(outfile, level, name_='geo3dType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alignType', node)
        if value is not None and 'alignType' not in already_processed:
            already_processed.add('alignType')
            self.alignType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'alignObject':
            obj_ = alignObjectType.factory()
            obj_.build(child_)
            self.alignObject.append(obj_)
            obj_.original_tagname_ = 'alignObject'
        elif nodeName_ == 'score':
            obj_ = scoreType.factory()
            obj_.build(child_)
            self.score.append(obj_)
            obj_.original_tagname_ = 'score'
        elif nodeName_ == 'block':
            obj_ = blockType.factory()
            obj_.build(child_)
            self.block.append(obj_)
            obj_.original_tagname_ = 'block'
        elif nodeName_ == 'geo3d':
            obj_ = geo3dType.factory()
            obj_.build(child_)
            self.geo3d.append(obj_)
            obj_.original_tagname_ = 'geo3d'
# end class alignment


class RDF(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Description=None):
        self.original_tagname_ = None
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
    def factory(*args_, **kwargs_):
        if RDF.subclass:
            return RDF.subclass(*args_, **kwargs_)
        else:
            return RDF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def hasContent_(self):
        if (
            self.Description
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RDF', namespacedef_=' xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RDF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RDF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RDF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RDF', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_='rdf:', name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RDF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Description.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
# end class RDF


class Description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, about=None, any=None):
        self.original_tagname_ = None
        self.about = _cast(None, about)
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if Description.subclass:
            return Description.subclass(*args_, **kwargs_)
        else:
            return Description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def get_about(self): return self.about
    def set_about(self, about): self.about = about
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Description', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Description'):
        if self.about is not None and 'about' not in already_processed:
            already_processed.add('about')
            outfile.write(' about=%s' % (self.gds_format_string(quote_attrib(self.about).encode(ExternalEncoding), input_name='about'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Description', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_='dc:', name_='any', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.about is not None and 'about' not in already_processed:
            already_processed.add('about')
            showIndent(outfile, level)
            outfile.write('about="%s",\n' % (self.about,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('any=[\n')
        level += 1
        for any_ in self.any:
            showIndent(outfile, level)
            outfile.write('model_.any(\n')
            any_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('about', node)
        if value is not None and 'about' not in already_processed:
            already_processed.add('about')
            self.about = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            obj_ = any.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
# end class Description


class any(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resource=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.resource = _cast(None, resource)
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if any.subclass:
            return any.subclass(*args_, **kwargs_)
        else:
            return any(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='any', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='any')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='any', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='any'):
        if self.resource is not None and 'resource' not in already_processed:
            already_processed.add('resource')
            outfile.write(' resource=%s' % (self.gds_format_string(quote_attrib(self.resource).encode(ExternalEncoding), input_name='resource'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='any', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='any'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.resource is not None and 'resource' not in already_processed:
            already_processed.add('resource')
            showIndent(outfile, level)
            outfile.write('resource="%s",\n' % (self.resource,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resource', node)
        if value is not None and 'resource' not in already_processed:
            already_processed.add('resource')
            self.resource = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class any


class title(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if title.subclass:
            return title.subclass(*args_, **kwargs_)
        else:
            return title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='title', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='title')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='title', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='title'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='title', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='title'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class title


class creator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if creator.subclass:
            return creator.subclass(*args_, **kwargs_)
        else:
            return creator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='creator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='creator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='creator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='creator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='creator', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='creator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class creator


class subject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if subject.subclass:
            return subject.subclass(*args_, **kwargs_)
        else:
            return subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='subject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='subject', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='subject'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subject', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='subject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subject


class description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='description', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='description'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='description', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class description


class publisher(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if publisher.subclass:
            return publisher.subclass(*args_, **kwargs_)
        else:
            return publisher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='publisher', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='publisher')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='publisher', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='publisher'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='publisher', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='publisher'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class publisher


class contributor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if contributor.subclass:
            return contributor.subclass(*args_, **kwargs_)
        else:
            return contributor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contributor', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contributor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='contributor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contributor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='contributor', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='contributor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contributor


class date(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if date.subclass:
            return date.subclass(*args_, **kwargs_)
        else:
            return date(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='date', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='date')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='date', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='date'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='date', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='date'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class date


class type_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class type_


class format(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if format.subclass:
            return format.subclass(*args_, **kwargs_)
        else:
            return format(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='format', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='format')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='format', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='format'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='format', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='format'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class format


class identifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if identifier.subclass:
            return identifier.subclass(*args_, **kwargs_)
        else:
            return identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='identifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='identifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='identifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='identifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class identifier


class source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='source', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='source', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='source'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='source', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class source


class language(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if language.subclass:
            return language.subclass(*args_, **kwargs_)
        else:
            return language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='language', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='language')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='language', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='language'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='language', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='language'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class language


class relation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if relation.subclass:
            return relation.subclass(*args_, **kwargs_)
        else:
            return relation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='relation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='relation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='relation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='relation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='relation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class relation


class coverage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if coverage.subclass:
            return coverage.subclass(*args_, **kwargs_)
        else:
            return coverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='coverage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='coverage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='coverage'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='coverage', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='coverage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class coverage


class rights(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if rights.subclass:
            return rights.subclass(*args_, **kwargs_)
        else:
            return rights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='rights', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='rights', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rights'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='rights', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rights'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rights


class listDBType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, db=None):
        self.original_tagname_ = None
        if db is None:
            self.db = []
        else:
            self.db = db
    def factory(*args_, **kwargs_):
        if listDBType.subclass:
            return listDBType.subclass(*args_, **kwargs_)
        else:
            return listDBType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_db(self): return self.db
    def set_db(self, db): self.db = db
    def add_db(self, value): self.db.append(value)
    def insert_db_at(self, index, value): self.db.insert(index, value)
    def replace_db_at(self, index, value): self.db[index] = value
    def hasContent_(self):
        if (
            self.db
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='listDBType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='listDBType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='listDBType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='listDBType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='listDBType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for db_ in self.db:
            db_.export(outfile, level, namespace_, name_='db', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='listDBType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('db=[\n')
        level += 1
        for db_ in self.db:
            showIndent(outfile, level)
            outfile.write('model_.dbType(\n')
            db_.exportLiteral(outfile, level, name_='dbType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'db':
            obj_ = dbType.factory()
            obj_.build(child_)
            self.db.append(obj_)
            obj_.original_tagname_ = 'db'
# end class listDBType


class dbType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dbVersion=None, dbSource=None, dbCoordSys=None):
        self.original_tagname_ = None
        self.dbVersion = _cast(None, dbVersion)
        self.dbSource = _cast(None, dbSource)
        self.dbCoordSys = _cast(None, dbCoordSys)
    def factory(*args_, **kwargs_):
        if dbType.subclass:
            return dbType.subclass(*args_, **kwargs_)
        else:
            return dbType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dbVersion(self): return self.dbVersion
    def set_dbVersion(self, dbVersion): self.dbVersion = dbVersion
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_dbCoordSys(self): return self.dbCoordSys
    def set_dbCoordSys(self, dbCoordSys): self.dbCoordSys = dbCoordSys
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dbType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dbType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dbType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dbType'):
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            outfile.write(' dbVersion=%s' % (self.gds_format_string(quote_attrib(self.dbVersion).encode(ExternalEncoding), input_name='dbVersion'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            outfile.write(' dbCoordSys=%s' % (self.gds_format_string(quote_attrib(self.dbCoordSys).encode(ExternalEncoding), input_name='dbCoordSys'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dbType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dbType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            showIndent(outfile, level)
            outfile.write('dbVersion="%s",\n' % (self.dbVersion,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            showIndent(outfile, level)
            outfile.write('dbCoordSys="%s",\n' % (self.dbCoordSys,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dbVersion', node)
        if value is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            self.dbVersion = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
        value = find_attr_value_('dbCoordSys', node)
        if value is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            self.dbCoordSys = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dbType


class entryDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None, dbSource=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.property = _cast(None, property)
        self.dbSource = _cast(None, dbSource)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if entryDetailType.subclass:
            return entryDetailType.subclass(*args_, **kwargs_)
        else:
            return entryDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entryDetailType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entryDetailType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entryDetailType'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='entryDetailType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='entryDetailType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            showIndent(outfile, level)
            outfile.write('property="%s",\n' % (self.property,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class entryDetailType


class entityType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, entityId=None, type_=None, entityDetail=None, segment=None):
        self.original_tagname_ = None
        self.entityId = _cast(None, entityId)
        self.type_ = _cast(None, type_)
        if entityDetail is None:
            self.entityDetail = []
        else:
            self.entityDetail = entityDetail
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
    def factory(*args_, **kwargs_):
        if entityType1.subclass:
            return entityType1.subclass(*args_, **kwargs_)
        else:
            return entityType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityDetail(self): return self.entityDetail
    def set_entityDetail(self, entityDetail): self.entityDetail = entityDetail
    def add_entityDetail(self, value): self.entityDetail.append(value)
    def insert_entityDetail_at(self, index, value): self.entityDetail.insert(index, value)
    def replace_entityDetail_at(self, index, value): self.entityDetail[index] = value
    def get_segment(self): return self.segment
    def set_segment(self, segment): self.segment = segment
    def add_segment(self, value): self.segment.append(value)
    def insert_segment_at(self, index, value): self.segment.insert(index, value)
    def replace_segment_at(self, index, value): self.segment[index] = value
    def get_entityId(self): return self.entityId
    def set_entityId(self, entityId): self.entityId = entityId
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.entityDetail or
            self.segment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entityType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entityType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='entityType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entityType1'):
        if self.entityId is not None and 'entityId' not in already_processed:
            already_processed.add('entityId')
            outfile.write(' entityId=%s' % (self.gds_format_string(quote_attrib(self.entityId).encode(ExternalEncoding), input_name='entityId'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='entityType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for entityDetail_ in self.entityDetail:
            entityDetail_.export(outfile, level, namespace_, name_='entityDetail', pretty_print=pretty_print)
        for segment_ in self.segment:
            segment_.export(outfile, level, namespace_, name_='segment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='entityType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.entityId is not None and 'entityId' not in already_processed:
            already_processed.add('entityId')
            showIndent(outfile, level)
            outfile.write('entityId="%s",\n' % (self.entityId,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('entityDetail=[\n')
        level += 1
        for entityDetail_ in self.entityDetail:
            showIndent(outfile, level)
            outfile.write('model_.entityDetailType(\n')
            entityDetail_.exportLiteral(outfile, level, name_='entityDetailType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('segment=[\n')
        level += 1
        for segment_ in self.segment:
            showIndent(outfile, level)
            outfile.write('model_.segmentType(\n')
            segment_.exportLiteral(outfile, level, name_='segmentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entityId', node)
        if value is not None and 'entityId' not in already_processed:
            already_processed.add('entityId')
            self.entityId = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entityDetail':
            obj_ = entityDetailType.factory()
            obj_.build(child_)
            self.entityDetail.append(obj_)
            obj_.original_tagname_ = 'entityDetail'
        elif nodeName_ == 'segment':
            obj_ = segmentType.factory()
            obj_.build(child_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
# end class entityType1


class entityDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None, dbSource=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.property = _cast(None, property)
        self.dbSource = _cast(None, dbSource)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if entityDetailType.subclass:
            return entityDetailType.subclass(*args_, **kwargs_)
        else:
            return entityDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entityDetailType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entityDetailType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entityDetailType'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='entityDetailType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='entityDetailType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            showIndent(outfile, level)
            outfile.write('property="%s",\n' % (self.property,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class entityDetailType


class segmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, segId=None, end=None, start=None, listResidue=None, listMapRegion=None, segmentDetail=None):
        self.original_tagname_ = None
        self.segId = _cast(None, segId)
        self.end = _cast(None, end)
        self.start = _cast(None, start)
        self.listResidue = listResidue
        self.listMapRegion = listMapRegion
        if segmentDetail is None:
            self.segmentDetail = []
        else:
            self.segmentDetail = segmentDetail
    def factory(*args_, **kwargs_):
        if segmentType.subclass:
            return segmentType.subclass(*args_, **kwargs_)
        else:
            return segmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_listResidue(self): return self.listResidue
    def set_listResidue(self, listResidue): self.listResidue = listResidue
    def get_listMapRegion(self): return self.listMapRegion
    def set_listMapRegion(self, listMapRegion): self.listMapRegion = listMapRegion
    def get_segmentDetail(self): return self.segmentDetail
    def set_segmentDetail(self, segmentDetail): self.segmentDetail = segmentDetail
    def add_segmentDetail(self, value): self.segmentDetail.append(value)
    def insert_segmentDetail_at(self, index, value): self.segmentDetail.insert(index, value)
    def replace_segmentDetail_at(self, index, value): self.segmentDetail[index] = value
    def get_segId(self): return self.segId
    def set_segId(self, segId): self.segId = segId
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def hasContent_(self):
        if (
            self.listResidue is not None or
            self.listMapRegion is not None or
            self.segmentDetail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='segmentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='segmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='segmentType'):
        if self.segId is not None and 'segId' not in already_processed:
            already_processed.add('segId')
            outfile.write(' segId=%s' % (self.gds_format_string(quote_attrib(self.segId).encode(ExternalEncoding), input_name='segId'), ))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            outfile.write(' end=%s' % (self.gds_format_string(quote_attrib(self.end).encode(ExternalEncoding), input_name='end'), ))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_format_string(quote_attrib(self.start).encode(ExternalEncoding), input_name='start'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='segmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.listResidue is not None:
            self.listResidue.export(outfile, level, namespace_, name_='listResidue', pretty_print=pretty_print)
        if self.listMapRegion is not None:
            self.listMapRegion.export(outfile, level, namespace_, name_='listMapRegion', pretty_print=pretty_print)
        for segmentDetail_ in self.segmentDetail:
            segmentDetail_.export(outfile, level, namespace_, name_='segmentDetail', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='segmentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.segId is not None and 'segId' not in already_processed:
            already_processed.add('segId')
            showIndent(outfile, level)
            outfile.write('segId="%s",\n' % (self.segId,))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            showIndent(outfile, level)
            outfile.write('end="%s",\n' % (self.end,))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start="%s",\n' % (self.start,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.listResidue is not None:
            showIndent(outfile, level)
            outfile.write('listResidue=model_.listResidueType(\n')
            self.listResidue.exportLiteral(outfile, level, name_='listResidue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.listMapRegion is not None:
            showIndent(outfile, level)
            outfile.write('listMapRegion=model_.listMapRegionType(\n')
            self.listMapRegion.exportLiteral(outfile, level, name_='listMapRegion')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('segmentDetail=[\n')
        level += 1
        for segmentDetail_ in self.segmentDetail:
            showIndent(outfile, level)
            outfile.write('model_.segmentDetailType(\n')
            segmentDetail_.exportLiteral(outfile, level, name_='segmentDetailType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segId', node)
        if value is not None and 'segId' not in already_processed:
            already_processed.add('segId')
            self.segId = value
        value = find_attr_value_('end', node)
        if value is not None and 'end' not in already_processed:
            already_processed.add('end')
            self.end = value
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'listResidue':
            obj_ = listResidueType.factory()
            obj_.build(child_)
            self.listResidue = obj_
            obj_.original_tagname_ = 'listResidue'
        elif nodeName_ == 'listMapRegion':
            obj_ = listMapRegionType.factory()
            obj_.build(child_)
            self.listMapRegion = obj_
            obj_.original_tagname_ = 'listMapRegion'
        elif nodeName_ == 'segmentDetail':
            obj_ = segmentDetailType.factory()
            obj_.build(child_)
            self.segmentDetail.append(obj_)
            obj_.original_tagname_ = 'segmentDetail'
# end class segmentType


class listResidueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, residue=None):
        self.original_tagname_ = None
        if residue is None:
            self.residue = []
        else:
            self.residue = residue
    def factory(*args_, **kwargs_):
        if listResidueType.subclass:
            return listResidueType.subclass(*args_, **kwargs_)
        else:
            return listResidueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_residue(self): return self.residue
    def set_residue(self, residue): self.residue = residue
    def add_residue(self, value): self.residue.append(value)
    def insert_residue_at(self, index, value): self.residue.insert(index, value)
    def replace_residue_at(self, index, value): self.residue[index] = value
    def hasContent_(self):
        if (
            self.residue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='listResidueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='listResidueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='listResidueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='listResidueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='listResidueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for residue_ in self.residue:
            residue_.export(outfile, level, namespace_, name_='residue', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='listResidueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('residue=[\n')
        level += 1
        for residue_ in self.residue:
            showIndent(outfile, level)
            outfile.write('model_.residueType(\n')
            residue_.exportLiteral(outfile, level, name_='residueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'residue':
            obj_ = residueType.factory()
            obj_.build(child_)
            self.residue.append(obj_)
            obj_.original_tagname_ = 'residue'
# end class listResidueType


class residueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dbResNum=None, dbVersion=None, dbResName=None, dbSource=None, dbCoordSys=None, crossRefDb=None, residueDetail=None):
        self.original_tagname_ = None
        self.dbResNum = _cast(None, dbResNum)
        self.dbVersion = _cast(None, dbVersion)
        self.dbResName = _cast(None, dbResName)
        self.dbSource = _cast(None, dbSource)
        self.dbCoordSys = _cast(None, dbCoordSys)
        if crossRefDb is None:
            self.crossRefDb = []
        else:
            self.crossRefDb = crossRefDb
        if residueDetail is None:
            self.residueDetail = []
        else:
            self.residueDetail = residueDetail
    def factory(*args_, **kwargs_):
        if residueType.subclass:
            return residueType.subclass(*args_, **kwargs_)
        else:
            return residueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_crossRefDb(self): return self.crossRefDb
    def set_crossRefDb(self, crossRefDb): self.crossRefDb = crossRefDb
    def add_crossRefDb(self, value): self.crossRefDb.append(value)
    def insert_crossRefDb_at(self, index, value): self.crossRefDb.insert(index, value)
    def replace_crossRefDb_at(self, index, value): self.crossRefDb[index] = value
    def get_residueDetail(self): return self.residueDetail
    def set_residueDetail(self, residueDetail): self.residueDetail = residueDetail
    def add_residueDetail(self, value): self.residueDetail.append(value)
    def insert_residueDetail_at(self, index, value): self.residueDetail.insert(index, value)
    def replace_residueDetail_at(self, index, value): self.residueDetail[index] = value
    def get_dbResNum(self): return self.dbResNum
    def set_dbResNum(self, dbResNum): self.dbResNum = dbResNum
    def get_dbVersion(self): return self.dbVersion
    def set_dbVersion(self, dbVersion): self.dbVersion = dbVersion
    def get_dbResName(self): return self.dbResName
    def set_dbResName(self, dbResName): self.dbResName = dbResName
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_dbCoordSys(self): return self.dbCoordSys
    def set_dbCoordSys(self, dbCoordSys): self.dbCoordSys = dbCoordSys
    def hasContent_(self):
        if (
            self.crossRefDb or
            self.residueDetail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='residueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='residueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='residueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='residueType'):
        if self.dbResNum is not None and 'dbResNum' not in already_processed:
            already_processed.add('dbResNum')
            outfile.write(' dbResNum=%s' % (self.gds_format_string(quote_attrib(self.dbResNum).encode(ExternalEncoding), input_name='dbResNum'), ))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            outfile.write(' dbVersion=%s' % (self.gds_format_string(quote_attrib(self.dbVersion).encode(ExternalEncoding), input_name='dbVersion'), ))
        if self.dbResName is not None and 'dbResName' not in already_processed:
            already_processed.add('dbResName')
            outfile.write(' dbResName=%s' % (self.gds_format_string(quote_attrib(self.dbResName).encode(ExternalEncoding), input_name='dbResName'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            outfile.write(' dbCoordSys=%s' % (self.gds_format_string(quote_attrib(self.dbCoordSys).encode(ExternalEncoding), input_name='dbCoordSys'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='residueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for crossRefDb_ in self.crossRefDb:
            crossRefDb_.export(outfile, level, namespace_, name_='crossRefDb', pretty_print=pretty_print)
        for residueDetail_ in self.residueDetail:
            residueDetail_.export(outfile, level, namespace_, name_='residueDetail', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='residueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dbResNum is not None and 'dbResNum' not in already_processed:
            already_processed.add('dbResNum')
            showIndent(outfile, level)
            outfile.write('dbResNum="%s",\n' % (self.dbResNum,))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            showIndent(outfile, level)
            outfile.write('dbVersion="%s",\n' % (self.dbVersion,))
        if self.dbResName is not None and 'dbResName' not in already_processed:
            already_processed.add('dbResName')
            showIndent(outfile, level)
            outfile.write('dbResName="%s",\n' % (self.dbResName,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            showIndent(outfile, level)
            outfile.write('dbCoordSys="%s",\n' % (self.dbCoordSys,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('crossRefDb=[\n')
        level += 1
        for crossRefDb_ in self.crossRefDb:
            showIndent(outfile, level)
            outfile.write('model_.crossRefDbType(\n')
            crossRefDb_.exportLiteral(outfile, level, name_='crossRefDbType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('residueDetail=[\n')
        level += 1
        for residueDetail_ in self.residueDetail:
            showIndent(outfile, level)
            outfile.write('model_.residueDetailType(\n')
            residueDetail_.exportLiteral(outfile, level, name_='residueDetailType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dbResNum', node)
        if value is not None and 'dbResNum' not in already_processed:
            already_processed.add('dbResNum')
            self.dbResNum = value
        value = find_attr_value_('dbVersion', node)
        if value is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            self.dbVersion = value
        value = find_attr_value_('dbResName', node)
        if value is not None and 'dbResName' not in already_processed:
            already_processed.add('dbResName')
            self.dbResName = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
        value = find_attr_value_('dbCoordSys', node)
        if value is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            self.dbCoordSys = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'crossRefDb':
            obj_ = crossRefDbType.factory()
            obj_.build(child_)
            self.crossRefDb.append(obj_)
            obj_.original_tagname_ = 'crossRefDb'
        elif nodeName_ == 'residueDetail':
            obj_ = residueDetailType.factory()
            obj_.build(child_)
            self.residueDetail.append(obj_)
            obj_.original_tagname_ = 'residueDetail'
# end class residueType


class crossRefDbType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dbEvidence=None, dbChainId=None, dbVersion=None, dbResNum=None, dbAccessionId=None, dbResName=None, dbSource=None, dbCoordSys=None):
        self.original_tagname_ = None
        self.dbEvidence = _cast(None, dbEvidence)
        self.dbChainId = _cast(None, dbChainId)
        self.dbVersion = _cast(None, dbVersion)
        self.dbResNum = _cast(None, dbResNum)
        self.dbAccessionId = _cast(None, dbAccessionId)
        self.dbResName = _cast(None, dbResName)
        self.dbSource = _cast(None, dbSource)
        self.dbCoordSys = _cast(None, dbCoordSys)
    def factory(*args_, **kwargs_):
        if crossRefDbType.subclass:
            return crossRefDbType.subclass(*args_, **kwargs_)
        else:
            return crossRefDbType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dbEvidence(self): return self.dbEvidence
    def set_dbEvidence(self, dbEvidence): self.dbEvidence = dbEvidence
    def get_dbChainId(self): return self.dbChainId
    def set_dbChainId(self, dbChainId): self.dbChainId = dbChainId
    def get_dbVersion(self): return self.dbVersion
    def set_dbVersion(self, dbVersion): self.dbVersion = dbVersion
    def get_dbResNum(self): return self.dbResNum
    def set_dbResNum(self, dbResNum): self.dbResNum = dbResNum
    def get_dbAccessionId(self): return self.dbAccessionId
    def set_dbAccessionId(self, dbAccessionId): self.dbAccessionId = dbAccessionId
    def get_dbResName(self): return self.dbResName
    def set_dbResName(self, dbResName): self.dbResName = dbResName
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_dbCoordSys(self): return self.dbCoordSys
    def set_dbCoordSys(self, dbCoordSys): self.dbCoordSys = dbCoordSys
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='crossRefDbType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='crossRefDbType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='crossRefDbType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='crossRefDbType'):
        if self.dbEvidence is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            outfile.write(' dbEvidence=%s' % (self.gds_format_string(quote_attrib(self.dbEvidence).encode(ExternalEncoding), input_name='dbEvidence'), ))
        if self.dbChainId is not None and 'dbChainId' not in already_processed:
            already_processed.add('dbChainId')
            outfile.write(' dbChainId=%s' % (quote_attrib(self.dbChainId), ))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            outfile.write(' dbVersion=%s' % (self.gds_format_string(quote_attrib(self.dbVersion).encode(ExternalEncoding), input_name='dbVersion'), ))
        if self.dbResNum is not None and 'dbResNum' not in already_processed:
            already_processed.add('dbResNum')
            outfile.write(' dbResNum=%s' % (self.gds_format_string(quote_attrib(self.dbResNum).encode(ExternalEncoding), input_name='dbResNum'), ))
        if self.dbAccessionId is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            outfile.write(' dbAccessionId=%s' % (self.gds_format_string(quote_attrib(self.dbAccessionId).encode(ExternalEncoding), input_name='dbAccessionId'), ))
        if self.dbResName is not None and 'dbResName' not in already_processed:
            already_processed.add('dbResName')
            outfile.write(' dbResName=%s' % (self.gds_format_string(quote_attrib(self.dbResName).encode(ExternalEncoding), input_name='dbResName'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            outfile.write(' dbCoordSys=%s' % (self.gds_format_string(quote_attrib(self.dbCoordSys).encode(ExternalEncoding), input_name='dbCoordSys'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='crossRefDbType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='crossRefDbType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dbEvidence is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            showIndent(outfile, level)
            outfile.write('dbEvidence="%s",\n' % (self.dbEvidence,))
        if self.dbChainId is not None and 'dbChainId' not in already_processed:
            already_processed.add('dbChainId')
            showIndent(outfile, level)
            outfile.write('dbChainId=%s,\n' % (self.dbChainId,))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            showIndent(outfile, level)
            outfile.write('dbVersion="%s",\n' % (self.dbVersion,))
        if self.dbResNum is not None and 'dbResNum' not in already_processed:
            already_processed.add('dbResNum')
            showIndent(outfile, level)
            outfile.write('dbResNum="%s",\n' % (self.dbResNum,))
        if self.dbAccessionId is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            showIndent(outfile, level)
            outfile.write('dbAccessionId="%s",\n' % (self.dbAccessionId,))
        if self.dbResName is not None and 'dbResName' not in already_processed:
            already_processed.add('dbResName')
            showIndent(outfile, level)
            outfile.write('dbResName="%s",\n' % (self.dbResName,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            showIndent(outfile, level)
            outfile.write('dbCoordSys="%s",\n' % (self.dbCoordSys,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dbEvidence', node)
        if value is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            self.dbEvidence = value
        value = find_attr_value_('dbChainId', node)
        if value is not None and 'dbChainId' not in already_processed:
            already_processed.add('dbChainId')
            self.dbChainId = value
        value = find_attr_value_('dbVersion', node)
        if value is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            self.dbVersion = value
        value = find_attr_value_('dbResNum', node)
        if value is not None and 'dbResNum' not in already_processed:
            already_processed.add('dbResNum')
            self.dbResNum = value
        value = find_attr_value_('dbAccessionId', node)
        if value is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            self.dbAccessionId = value
        value = find_attr_value_('dbResName', node)
        if value is not None and 'dbResName' not in already_processed:
            already_processed.add('dbResName')
            self.dbResName = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
        value = find_attr_value_('dbCoordSys', node)
        if value is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            self.dbCoordSys = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class crossRefDbType


class residueDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None, dbSource=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.property = _cast(None, property)
        self.dbSource = _cast(None, dbSource)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if residueDetailType.subclass:
            return residueDetailType.subclass(*args_, **kwargs_)
        else:
            return residueDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='residueDetailType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='residueDetailType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='residueDetailType'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='residueDetailType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='residueDetailType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            showIndent(outfile, level)
            outfile.write('property="%s",\n' % (self.property,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class residueDetailType


class listMapRegionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mapRegion=None):
        self.original_tagname_ = None
        if mapRegion is None:
            self.mapRegion = []
        else:
            self.mapRegion = mapRegion
    def factory(*args_, **kwargs_):
        if listMapRegionType.subclass:
            return listMapRegionType.subclass(*args_, **kwargs_)
        else:
            return listMapRegionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mapRegion(self): return self.mapRegion
    def set_mapRegion(self, mapRegion): self.mapRegion = mapRegion
    def add_mapRegion(self, value): self.mapRegion.append(value)
    def insert_mapRegion_at(self, index, value): self.mapRegion.insert(index, value)
    def replace_mapRegion_at(self, index, value): self.mapRegion[index] = value
    def hasContent_(self):
        if (
            self.mapRegion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='listMapRegionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='listMapRegionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='listMapRegionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='listMapRegionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='listMapRegionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mapRegion_ in self.mapRegion:
            mapRegion_.export(outfile, level, namespace_, name_='mapRegion', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='listMapRegionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mapRegion=[\n')
        level += 1
        for mapRegion_ in self.mapRegion:
            showIndent(outfile, level)
            outfile.write('model_.mapRegionType(\n')
            mapRegion_.exportLiteral(outfile, level, name_='mapRegionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mapRegion':
            obj_ = mapRegionType.factory()
            obj_.build(child_)
            self.mapRegion.append(obj_)
            obj_.original_tagname_ = 'mapRegion'
# end class listMapRegionType


class mapRegionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, start=None, end=None, db=None):
        self.original_tagname_ = None
        self.start = _cast(None, start)
        self.end = _cast(None, end)
        self.db = db
    def factory(*args_, **kwargs_):
        if mapRegionType.subclass:
            return mapRegionType.subclass(*args_, **kwargs_)
        else:
            return mapRegionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_db(self): return self.db
    def set_db(self, db): self.db = db
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def hasContent_(self):
        if (
            self.db is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mapRegionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mapRegionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mapRegionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mapRegionType'):
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_format_string(quote_attrib(self.start).encode(ExternalEncoding), input_name='start'), ))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            outfile.write(' end=%s' % (self.gds_format_string(quote_attrib(self.end).encode(ExternalEncoding), input_name='end'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mapRegionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.db is not None:
            self.db.export(outfile, level, namespace_, name_='db', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mapRegionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start="%s",\n' % (self.start,))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            showIndent(outfile, level)
            outfile.write('end="%s",\n' % (self.end,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.db is not None:
            showIndent(outfile, level)
            outfile.write('db=model_.dbType2(\n')
            self.db.exportLiteral(outfile, level, name_='db')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
        value = find_attr_value_('end', node)
        if value is not None and 'end' not in already_processed:
            already_processed.add('end')
            self.end = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'db':
            obj_ = dbType2.factory()
            obj_.build(child_)
            self.db = obj_
            obj_.original_tagname_ = 'db'
# end class mapRegionType


class dbType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dbEvidence=None, end=None, dbChainId=None, dbVersion=None, dbAccessionId=None, start=None, dbSource=None, dbCoordSys=None, dbDetail=None):
        self.original_tagname_ = None
        self.dbEvidence = _cast(None, dbEvidence)
        self.end = _cast(None, end)
        self.dbChainId = _cast(None, dbChainId)
        self.dbVersion = _cast(None, dbVersion)
        self.dbAccessionId = _cast(None, dbAccessionId)
        self.start = _cast(None, start)
        self.dbSource = _cast(None, dbSource)
        self.dbCoordSys = _cast(None, dbCoordSys)
        if dbDetail is None:
            self.dbDetail = []
        else:
            self.dbDetail = dbDetail
    def factory(*args_, **kwargs_):
        if dbType2.subclass:
            return dbType2.subclass(*args_, **kwargs_)
        else:
            return dbType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dbDetail(self): return self.dbDetail
    def set_dbDetail(self, dbDetail): self.dbDetail = dbDetail
    def add_dbDetail(self, value): self.dbDetail.append(value)
    def insert_dbDetail_at(self, index, value): self.dbDetail.insert(index, value)
    def replace_dbDetail_at(self, index, value): self.dbDetail[index] = value
    def get_dbEvidence(self): return self.dbEvidence
    def set_dbEvidence(self, dbEvidence): self.dbEvidence = dbEvidence
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_dbChainId(self): return self.dbChainId
    def set_dbChainId(self, dbChainId): self.dbChainId = dbChainId
    def get_dbVersion(self): return self.dbVersion
    def set_dbVersion(self, dbVersion): self.dbVersion = dbVersion
    def get_dbAccessionId(self): return self.dbAccessionId
    def set_dbAccessionId(self, dbAccessionId): self.dbAccessionId = dbAccessionId
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_dbCoordSys(self): return self.dbCoordSys
    def set_dbCoordSys(self, dbCoordSys): self.dbCoordSys = dbCoordSys
    def hasContent_(self):
        if (
            self.dbDetail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dbType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dbType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dbType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dbType2'):
        if self.dbEvidence is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            outfile.write(' dbEvidence=%s' % (self.gds_format_string(quote_attrib(self.dbEvidence).encode(ExternalEncoding), input_name='dbEvidence'), ))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            outfile.write(' end=%s' % (self.gds_format_string(quote_attrib(self.end).encode(ExternalEncoding), input_name='end'), ))
        if self.dbChainId is not None and 'dbChainId' not in already_processed:
            already_processed.add('dbChainId')
            outfile.write(' dbChainId=%s' % (quote_attrib(self.dbChainId), ))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            outfile.write(' dbVersion=%s' % (self.gds_format_string(quote_attrib(self.dbVersion).encode(ExternalEncoding), input_name='dbVersion'), ))
        if self.dbAccessionId is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            outfile.write(' dbAccessionId=%s' % (self.gds_format_string(quote_attrib(self.dbAccessionId).encode(ExternalEncoding), input_name='dbAccessionId'), ))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_format_string(quote_attrib(self.start).encode(ExternalEncoding), input_name='start'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            outfile.write(' dbCoordSys=%s' % (self.gds_format_string(quote_attrib(self.dbCoordSys).encode(ExternalEncoding), input_name='dbCoordSys'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dbType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dbDetail_ in self.dbDetail:
            dbDetail_.export(outfile, level, namespace_, name_='dbDetail', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='dbType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dbEvidence is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            showIndent(outfile, level)
            outfile.write('dbEvidence="%s",\n' % (self.dbEvidence,))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            showIndent(outfile, level)
            outfile.write('end="%s",\n' % (self.end,))
        if self.dbChainId is not None and 'dbChainId' not in already_processed:
            already_processed.add('dbChainId')
            showIndent(outfile, level)
            outfile.write('dbChainId=%s,\n' % (self.dbChainId,))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            showIndent(outfile, level)
            outfile.write('dbVersion="%s",\n' % (self.dbVersion,))
        if self.dbAccessionId is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            showIndent(outfile, level)
            outfile.write('dbAccessionId="%s",\n' % (self.dbAccessionId,))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start="%s",\n' % (self.start,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            showIndent(outfile, level)
            outfile.write('dbCoordSys="%s",\n' % (self.dbCoordSys,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dbDetail=[\n')
        level += 1
        for dbDetail_ in self.dbDetail:
            showIndent(outfile, level)
            outfile.write('model_.dbDetailType(\n')
            dbDetail_.exportLiteral(outfile, level, name_='dbDetailType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dbEvidence', node)
        if value is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            self.dbEvidence = value
        value = find_attr_value_('end', node)
        if value is not None and 'end' not in already_processed:
            already_processed.add('end')
            self.end = value
        value = find_attr_value_('dbChainId', node)
        if value is not None and 'dbChainId' not in already_processed:
            already_processed.add('dbChainId')
            self.dbChainId = value
        value = find_attr_value_('dbVersion', node)
        if value is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            self.dbVersion = value
        value = find_attr_value_('dbAccessionId', node)
        if value is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            self.dbAccessionId = value
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
        value = find_attr_value_('dbCoordSys', node)
        if value is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            self.dbCoordSys = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dbDetail':
            obj_ = dbDetailType.factory()
            obj_.build(child_)
            self.dbDetail.append(obj_)
            obj_.original_tagname_ = 'dbDetail'
# end class dbType2


class dbDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None, dbSource=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.property = _cast(None, property)
        self.dbSource = _cast(None, dbSource)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dbDetailType.subclass:
            return dbDetailType.subclass(*args_, **kwargs_)
        else:
            return dbDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dbDetailType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dbDetailType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dbDetailType'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dbDetailType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dbDetailType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            showIndent(outfile, level)
            outfile.write('property="%s",\n' % (self.property,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class dbDetailType


class segmentDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None, dbSource=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.property = _cast(None, property)
        self.dbSource = _cast(None, dbSource)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if segmentDetailType.subclass:
            return segmentDetailType.subclass(*args_, **kwargs_)
        else:
            return segmentDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='segmentDetailType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segmentDetailType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='segmentDetailType'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='segmentDetailType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='segmentDetailType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            showIndent(outfile, level)
            outfile.write('property="%s",\n' % (self.property,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class segmentDetailType


class alignObjectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dbEvidence=None, dbVersion=None, objectVersion=None, dbAccessionId=None, dbSource=None, intObjectId=None, type_=None, dbCoordSys=None, alignObjectDetail=None, sequence=None):
        self.original_tagname_ = None
        self.dbEvidence = _cast(None, dbEvidence)
        self.dbVersion = _cast(None, dbVersion)
        self.objectVersion = _cast(None, objectVersion)
        self.dbAccessionId = _cast(None, dbAccessionId)
        self.dbSource = _cast(None, dbSource)
        self.intObjectId = _cast(None, intObjectId)
        self.type_ = _cast(None, type_)
        self.dbCoordSys = _cast(None, dbCoordSys)
        if alignObjectDetail is None:
            self.alignObjectDetail = []
        else:
            self.alignObjectDetail = alignObjectDetail
        self.sequence = sequence
    def factory(*args_, **kwargs_):
        if alignObjectType.subclass:
            return alignObjectType.subclass(*args_, **kwargs_)
        else:
            return alignObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alignObjectDetail(self): return self.alignObjectDetail
    def set_alignObjectDetail(self, alignObjectDetail): self.alignObjectDetail = alignObjectDetail
    def add_alignObjectDetail(self, value): self.alignObjectDetail.append(value)
    def insert_alignObjectDetail_at(self, index, value): self.alignObjectDetail.insert(index, value)
    def replace_alignObjectDetail_at(self, index, value): self.alignObjectDetail[index] = value
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def get_dbEvidence(self): return self.dbEvidence
    def set_dbEvidence(self, dbEvidence): self.dbEvidence = dbEvidence
    def get_dbVersion(self): return self.dbVersion
    def set_dbVersion(self, dbVersion): self.dbVersion = dbVersion
    def get_objectVersion(self): return self.objectVersion
    def set_objectVersion(self, objectVersion): self.objectVersion = objectVersion
    def get_dbAccessionId(self): return self.dbAccessionId
    def set_dbAccessionId(self, dbAccessionId): self.dbAccessionId = dbAccessionId
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_intObjectId(self): return self.intObjectId
    def set_intObjectId(self, intObjectId): self.intObjectId = intObjectId
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_dbCoordSys(self): return self.dbCoordSys
    def set_dbCoordSys(self, dbCoordSys): self.dbCoordSys = dbCoordSys
    def hasContent_(self):
        if (
            self.alignObjectDetail or
            self.sequence is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alignObjectType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alignObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alignObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alignObjectType'):
        if self.dbEvidence is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            outfile.write(' dbEvidence=%s' % (self.gds_format_string(quote_attrib(self.dbEvidence).encode(ExternalEncoding), input_name='dbEvidence'), ))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            outfile.write(' dbVersion=%s' % (self.gds_format_string(quote_attrib(self.dbVersion).encode(ExternalEncoding), input_name='dbVersion'), ))
        if self.objectVersion is not None and 'objectVersion' not in already_processed:
            already_processed.add('objectVersion')
            outfile.write(' objectVersion=%s' % (self.gds_format_string(quote_attrib(self.objectVersion).encode(ExternalEncoding), input_name='objectVersion'), ))
        if self.dbAccessionId is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            outfile.write(' dbAccessionId=%s' % (self.gds_format_string(quote_attrib(self.dbAccessionId).encode(ExternalEncoding), input_name='dbAccessionId'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
        if self.intObjectId is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            outfile.write(' intObjectId=%s' % (self.gds_format_string(quote_attrib(self.intObjectId).encode(ExternalEncoding), input_name='intObjectId'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            outfile.write(' dbCoordSys=%s' % (self.gds_format_string(quote_attrib(self.dbCoordSys).encode(ExternalEncoding), input_name='dbCoordSys'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='alignObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alignObjectDetail_ in self.alignObjectDetail:
            alignObjectDetail_.export(outfile, level, namespace_, name_='alignObjectDetail', pretty_print=pretty_print)
        if self.sequence is not None:
            self.sequence.export(outfile, level, namespace_, name_='sequence', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='alignObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dbEvidence is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            showIndent(outfile, level)
            outfile.write('dbEvidence="%s",\n' % (self.dbEvidence,))
        if self.dbVersion is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            showIndent(outfile, level)
            outfile.write('dbVersion="%s",\n' % (self.dbVersion,))
        if self.objectVersion is not None and 'objectVersion' not in already_processed:
            already_processed.add('objectVersion')
            showIndent(outfile, level)
            outfile.write('objectVersion="%s",\n' % (self.objectVersion,))
        if self.dbAccessionId is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            showIndent(outfile, level)
            outfile.write('dbAccessionId="%s",\n' % (self.dbAccessionId,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
        if self.intObjectId is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            showIndent(outfile, level)
            outfile.write('intObjectId="%s",\n' % (self.intObjectId,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.dbCoordSys is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            showIndent(outfile, level)
            outfile.write('dbCoordSys="%s",\n' % (self.dbCoordSys,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('alignObjectDetail=[\n')
        level += 1
        for alignObjectDetail_ in self.alignObjectDetail:
            showIndent(outfile, level)
            outfile.write('model_.alignObjectDetailType(\n')
            alignObjectDetail_.exportLiteral(outfile, level, name_='alignObjectDetailType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.sequence is not None:
            showIndent(outfile, level)
            outfile.write('sequence=model_.sequenceType(\n')
            self.sequence.exportLiteral(outfile, level, name_='sequence')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dbEvidence', node)
        if value is not None and 'dbEvidence' not in already_processed:
            already_processed.add('dbEvidence')
            self.dbEvidence = value
        value = find_attr_value_('dbVersion', node)
        if value is not None and 'dbVersion' not in already_processed:
            already_processed.add('dbVersion')
            self.dbVersion = value
        value = find_attr_value_('objectVersion', node)
        if value is not None and 'objectVersion' not in already_processed:
            already_processed.add('objectVersion')
            self.objectVersion = value
        value = find_attr_value_('dbAccessionId', node)
        if value is not None and 'dbAccessionId' not in already_processed:
            already_processed.add('dbAccessionId')
            self.dbAccessionId = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
        value = find_attr_value_('intObjectId', node)
        if value is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            self.intObjectId = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('dbCoordSys', node)
        if value is not None and 'dbCoordSys' not in already_processed:
            already_processed.add('dbCoordSys')
            self.dbCoordSys = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'alignObjectDetail':
            obj_ = alignObjectDetailType.factory()
            obj_.build(child_)
            self.alignObjectDetail.append(obj_)
            obj_.original_tagname_ = 'alignObjectDetail'
        elif nodeName_ == 'sequence':
            obj_ = sequenceType.factory()
            obj_.build(child_)
            self.sequence = obj_
            obj_.original_tagname_ = 'sequence'
# end class alignObjectType


class alignObjectDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None, dbSource=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.property = _cast(None, property)
        self.dbSource = _cast(None, dbSource)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if alignObjectDetailType.subclass:
            return alignObjectDetailType.subclass(*args_, **kwargs_)
        else:
            return alignObjectDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def get_dbSource(self): return self.dbSource
    def set_dbSource(self, dbSource): self.dbSource = dbSource
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alignObjectDetailType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alignObjectDetailType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alignObjectDetailType'):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_format_string(quote_attrib(self.property).encode(ExternalEncoding), input_name='property'), ))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            outfile.write(' dbSource=%s' % (self.gds_format_string(quote_attrib(self.dbSource).encode(ExternalEncoding), input_name='dbSource'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='alignObjectDetailType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='alignObjectDetailType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            showIndent(outfile, level)
            outfile.write('property="%s",\n' % (self.property,))
        if self.dbSource is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            showIndent(outfile, level)
            outfile.write('dbSource="%s",\n' % (self.dbSource,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
        value = find_attr_value_('dbSource', node)
        if value is not None and 'dbSource' not in already_processed:
            already_processed.add('dbSource')
            self.dbSource = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class alignObjectDetailType


class sequenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, start=None, end=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.start = _cast(None, start)
        self.end = _cast(None, end)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sequenceType.subclass:
            return sequenceType.subclass(*args_, **kwargs_)
        else:
            return sequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sequenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sequenceType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sequenceType'):
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_format_string(quote_attrib(self.start).encode(ExternalEncoding), input_name='start'), ))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            outfile.write(' end=%s' % (self.gds_format_string(quote_attrib(self.end).encode(ExternalEncoding), input_name='end'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sequenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='sequenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start="%s",\n' % (self.start,))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            showIndent(outfile, level)
            outfile.write('end="%s",\n' % (self.end,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
        value = find_attr_value_('end', node)
        if value is not None and 'end' not in already_processed:
            already_processed.add('end')
            self.end = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class sequenceType


class scoreType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scoreValue=None, methodName=None):
        self.original_tagname_ = None
        self.scoreValue = _cast(None, scoreValue)
        self.methodName = _cast(None, methodName)
    def factory(*args_, **kwargs_):
        if scoreType.subclass:
            return scoreType.subclass(*args_, **kwargs_)
        else:
            return scoreType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scoreValue(self): return self.scoreValue
    def set_scoreValue(self, scoreValue): self.scoreValue = scoreValue
    def get_methodName(self): return self.methodName
    def set_methodName(self, methodName): self.methodName = methodName
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='scoreType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scoreType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='scoreType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scoreType'):
        if self.scoreValue is not None and 'scoreValue' not in already_processed:
            already_processed.add('scoreValue')
            outfile.write(' scoreValue=%s' % (self.gds_format_string(quote_attrib(self.scoreValue).encode(ExternalEncoding), input_name='scoreValue'), ))
        if self.methodName is not None and 'methodName' not in already_processed:
            already_processed.add('methodName')
            outfile.write(' methodName=%s' % (self.gds_format_string(quote_attrib(self.methodName).encode(ExternalEncoding), input_name='methodName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='scoreType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='scoreType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scoreValue is not None and 'scoreValue' not in already_processed:
            already_processed.add('scoreValue')
            showIndent(outfile, level)
            outfile.write('scoreValue="%s",\n' % (self.scoreValue,))
        if self.methodName is not None and 'methodName' not in already_processed:
            already_processed.add('methodName')
            showIndent(outfile, level)
            outfile.write('methodName="%s",\n' % (self.methodName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scoreValue', node)
        if value is not None and 'scoreValue' not in already_processed:
            already_processed.add('scoreValue')
            self.scoreValue = value
        value = find_attr_value_('methodName', node)
        if value is not None and 'methodName' not in already_processed:
            already_processed.add('methodName')
            self.methodName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class scoreType


class blockType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, blockScore=None, blockOrder=None, segment=None):
        self.original_tagname_ = None
        self.blockScore = _cast(None, blockScore)
        self.blockOrder = _cast(int, blockOrder)
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
    def factory(*args_, **kwargs_):
        if blockType.subclass:
            return blockType.subclass(*args_, **kwargs_)
        else:
            return blockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segment(self): return self.segment
    def set_segment(self, segment): self.segment = segment
    def add_segment(self, value): self.segment.append(value)
    def insert_segment_at(self, index, value): self.segment.insert(index, value)
    def replace_segment_at(self, index, value): self.segment[index] = value
    def get_blockScore(self): return self.blockScore
    def set_blockScore(self, blockScore): self.blockScore = blockScore
    def get_blockOrder(self): return self.blockOrder
    def set_blockOrder(self, blockOrder): self.blockOrder = blockOrder
    def hasContent_(self):
        if (
            self.segment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='blockType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='blockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='blockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='blockType'):
        if self.blockScore is not None and 'blockScore' not in already_processed:
            already_processed.add('blockScore')
            outfile.write(' blockScore=%s' % (self.gds_format_string(quote_attrib(self.blockScore).encode(ExternalEncoding), input_name='blockScore'), ))
        if self.blockOrder is not None and 'blockOrder' not in already_processed:
            already_processed.add('blockOrder')
            outfile.write(' blockOrder="%s"' % self.gds_format_integer(self.blockOrder, input_name='blockOrder'))
    def exportChildren(self, outfile, level, namespace_='', name_='blockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for segment_ in self.segment:
            segment_.export(outfile, level, namespace_, name_='segment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='blockType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.blockScore is not None and 'blockScore' not in already_processed:
            already_processed.add('blockScore')
            showIndent(outfile, level)
            outfile.write('blockScore="%s",\n' % (self.blockScore,))
        if self.blockOrder is not None and 'blockOrder' not in already_processed:
            already_processed.add('blockOrder')
            showIndent(outfile, level)
            outfile.write('blockOrder=%d,\n' % (self.blockOrder,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('segment=[\n')
        level += 1
        for segment_ in self.segment:
            showIndent(outfile, level)
            outfile.write('model_.segmentType3(\n')
            segment_.exportLiteral(outfile, level, name_='segmentType3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('blockScore', node)
        if value is not None and 'blockScore' not in already_processed:
            already_processed.add('blockScore')
            self.blockScore = value
        value = find_attr_value_('blockOrder', node)
        if value is not None and 'blockOrder' not in already_processed:
            already_processed.add('blockOrder')
            try:
                self.blockOrder = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segment':
            obj_ = segmentType3.factory()
            obj_.build(child_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
# end class blockType


class segmentType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, start=None, intObjectId=None, end=None, strand=None, cigar=None):
        self.original_tagname_ = None
        self.start = _cast(None, start)
        self.intObjectId = _cast(None, intObjectId)
        self.end = _cast(None, end)
        self.strand = _cast(None, strand)
        self.cigar = cigar
    def factory(*args_, **kwargs_):
        if segmentType3.subclass:
            return segmentType3.subclass(*args_, **kwargs_)
        else:
            return segmentType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cigar(self): return self.cigar
    def set_cigar(self, cigar): self.cigar = cigar
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_intObjectId(self): return self.intObjectId
    def set_intObjectId(self, intObjectId): self.intObjectId = intObjectId
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_strand(self): return self.strand
    def set_strand(self, strand): self.strand = strand
    def validate_cigarstring(self, value):
        # Validate type cigarstring, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.cigar is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='segmentType3', namespacedef_=' xmlns:data="http://www.ebi.ac.uk/pdbe/docs/sifts/dataTypes.xsd" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segmentType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='segmentType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='segmentType3'):
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_format_string(quote_attrib(self.start).encode(ExternalEncoding), input_name='start'), ))
        if self.intObjectId is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            outfile.write(' intObjectId=%s' % (self.gds_format_string(quote_attrib(self.intObjectId).encode(ExternalEncoding), input_name='intObjectId'), ))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            outfile.write(' end=%s' % (self.gds_format_string(quote_attrib(self.end).encode(ExternalEncoding), input_name='end'), ))
        if self.strand is not None and 'strand' not in already_processed:
            already_processed.add('strand')
            outfile.write(' strand=%s' % (self.gds_format_string(quote_attrib(self.strand).encode(ExternalEncoding), input_name='strand'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='segmentType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cigar is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scigar>%s</%scigar>%s' % (namespace_, self.gds_format_string(quote_xml(self.cigar).encode(ExternalEncoding), input_name='cigar'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='segmentType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start="%s",\n' % (self.start,))
        if self.intObjectId is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            showIndent(outfile, level)
            outfile.write('intObjectId="%s",\n' % (self.intObjectId,))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            showIndent(outfile, level)
            outfile.write('end="%s",\n' % (self.end,))
        if self.strand is not None and 'strand' not in already_processed:
            already_processed.add('strand')
            showIndent(outfile, level)
            outfile.write('strand="%s",\n' % (self.strand,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cigar is not None:
            showIndent(outfile, level)
            outfile.write('cigar=%s,\n' % quote_python(self.cigar).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
        value = find_attr_value_('intObjectId', node)
        if value is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            self.intObjectId = value
        value = find_attr_value_('end', node)
        if value is not None and 'end' not in already_processed:
            already_processed.add('end')
            self.end = value
        value = find_attr_value_('strand', node)
        if value is not None and 'strand' not in already_processed:
            already_processed.add('strand')
            self.strand = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cigar':
            cigar_ = child_.text
            cigar_ = self.gds_validate_string(cigar_, node, 'cigar')
            self.cigar = cigar_
            self.validate_cigarstring(self.cigar)    # validate type cigarstring
# end class segmentType3


class geo3dType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, intObjectId=None, vector=None, matrix=None):
        self.original_tagname_ = None
        self.intObjectId = _cast(None, intObjectId)
        self.vector = vector
        if matrix is None:
            self.matrix = []
        else:
            self.matrix = matrix
    def factory(*args_, **kwargs_):
        if geo3dType.subclass:
            return geo3dType.subclass(*args_, **kwargs_)
        else:
            return geo3dType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vector(self): return self.vector
    def set_vector(self, vector): self.vector = vector
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def add_matrix(self, value): self.matrix.append(value)
    def insert_matrix_at(self, index, value): self.matrix.insert(index, value)
    def replace_matrix_at(self, index, value): self.matrix[index] = value
    def get_intObjectId(self): return self.intObjectId
    def set_intObjectId(self, intObjectId): self.intObjectId = intObjectId
    def hasContent_(self):
        if (
            self.vector is not None or
            self.matrix
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='geo3dType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='geo3dType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='geo3dType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='geo3dType'):
        if self.intObjectId is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            outfile.write(' intObjectId=%s' % (self.gds_format_string(quote_attrib(self.intObjectId).encode(ExternalEncoding), input_name='intObjectId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='geo3dType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vector is not None:
            self.vector.export(outfile, level, namespace_, name_='vector', pretty_print=pretty_print)
        for matrix_ in self.matrix:
            matrix_.export(outfile, level, namespace_, name_='matrix', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='geo3dType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.intObjectId is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            showIndent(outfile, level)
            outfile.write('intObjectId="%s",\n' % (self.intObjectId,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.vector is not None:
            showIndent(outfile, level)
            outfile.write('vector=model_.vectorType(\n')
            self.vector.exportLiteral(outfile, level, name_='vector')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('matrix=[\n')
        level += 1
        for matrix_ in self.matrix:
            showIndent(outfile, level)
            outfile.write('model_.matrixType(\n')
            matrix_.exportLiteral(outfile, level, name_='matrixType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('intObjectId', node)
        if value is not None and 'intObjectId' not in already_processed:
            already_processed.add('intObjectId')
            self.intObjectId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vector':
            obj_ = vectorType.factory()
            obj_.build(child_)
            self.vector = obj_
            obj_.original_tagname_ = 'vector'
        elif nodeName_ == 'matrix':
            obj_ = matrixType.factory()
            obj_.build(child_)
            self.matrix.append(obj_)
            obj_.original_tagname_ = 'matrix'
# end class geo3dType


class vectorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None):
        self.original_tagname_ = None
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
    def factory(*args_, **kwargs_):
        if vectorType.subclass:
            return vectorType.subclass(*args_, **kwargs_)
        else:
            return vectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_z(self): return self.z
    def set_z(self, z): self.z = z
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vectorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vectorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vectorType'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_float(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_float(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_float(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespace_='', name_='vectorType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='vectorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%f,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%f,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%f,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            try:
                self.z = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vectorType


class matrixType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, max11=None, max12=None, max13=None, max21=None, max22=None, max23=None, max31=None, max32=None, max33=None):
        self.original_tagname_ = None
        self.max11 = max11
        self.max12 = max12
        self.max13 = max13
        self.max21 = max21
        self.max22 = max22
        self.max23 = max23
        self.max31 = max31
        self.max32 = max32
        self.max33 = max33
    def factory(*args_, **kwargs_):
        if matrixType.subclass:
            return matrixType.subclass(*args_, **kwargs_)
        else:
            return matrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max11(self): return self.max11
    def set_max11(self, max11): self.max11 = max11
    def get_max12(self): return self.max12
    def set_max12(self, max12): self.max12 = max12
    def get_max13(self): return self.max13
    def set_max13(self, max13): self.max13 = max13
    def get_max21(self): return self.max21
    def set_max21(self, max21): self.max21 = max21
    def get_max22(self): return self.max22
    def set_max22(self, max22): self.max22 = max22
    def get_max23(self): return self.max23
    def set_max23(self, max23): self.max23 = max23
    def get_max31(self): return self.max31
    def set_max31(self, max31): self.max31 = max31
    def get_max32(self): return self.max32
    def set_max32(self, max32): self.max32 = max32
    def get_max33(self): return self.max33
    def set_max33(self, max33): self.max33 = max33
    def hasContent_(self):
        if (
            self.max11 is not None or
            self.max12 is not None or
            self.max13 is not None or
            self.max21 is not None or
            self.max22 is not None or
            self.max23 is not None or
            self.max31 is not None or
            self.max32 is not None or
            self.max33 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='matrixType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matrixType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='matrixType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matrixType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='matrixType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.max11 is not None:
            self.max11.export(outfile, level, namespace_, name_='max11', pretty_print=pretty_print)
        if self.max12 is not None:
            self.max12.export(outfile, level, namespace_, name_='max12', pretty_print=pretty_print)
        if self.max13 is not None:
            self.max13.export(outfile, level, namespace_, name_='max13', pretty_print=pretty_print)
        if self.max21 is not None:
            self.max21.export(outfile, level, namespace_, name_='max21', pretty_print=pretty_print)
        if self.max22 is not None:
            self.max22.export(outfile, level, namespace_, name_='max22', pretty_print=pretty_print)
        if self.max23 is not None:
            self.max23.export(outfile, level, namespace_, name_='max23', pretty_print=pretty_print)
        if self.max31 is not None:
            self.max31.export(outfile, level, namespace_, name_='max31', pretty_print=pretty_print)
        if self.max32 is not None:
            self.max32.export(outfile, level, namespace_, name_='max32', pretty_print=pretty_print)
        if self.max33 is not None:
            self.max33.export(outfile, level, namespace_, name_='max33', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='matrixType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.max11 is not None:
            showIndent(outfile, level)
            outfile.write('max11=model_.max11Type(\n')
            self.max11.exportLiteral(outfile, level, name_='max11')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max12 is not None:
            showIndent(outfile, level)
            outfile.write('max12=model_.max12Type(\n')
            self.max12.exportLiteral(outfile, level, name_='max12')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max13 is not None:
            showIndent(outfile, level)
            outfile.write('max13=model_.max13Type(\n')
            self.max13.exportLiteral(outfile, level, name_='max13')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max21 is not None:
            showIndent(outfile, level)
            outfile.write('max21=model_.max21Type(\n')
            self.max21.exportLiteral(outfile, level, name_='max21')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max22 is not None:
            showIndent(outfile, level)
            outfile.write('max22=model_.max22Type(\n')
            self.max22.exportLiteral(outfile, level, name_='max22')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max23 is not None:
            showIndent(outfile, level)
            outfile.write('max23=model_.max23Type(\n')
            self.max23.exportLiteral(outfile, level, name_='max23')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max31 is not None:
            showIndent(outfile, level)
            outfile.write('max31=model_.max31Type(\n')
            self.max31.exportLiteral(outfile, level, name_='max31')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max32 is not None:
            showIndent(outfile, level)
            outfile.write('max32=model_.max32Type(\n')
            self.max32.exportLiteral(outfile, level, name_='max32')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max33 is not None:
            showIndent(outfile, level)
            outfile.write('max33=model_.max33Type(\n')
            self.max33.exportLiteral(outfile, level, name_='max33')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'max11':
            obj_ = max11Type.factory()
            obj_.build(child_)
            self.max11 = obj_
            obj_.original_tagname_ = 'max11'
        elif nodeName_ == 'max12':
            obj_ = max12Type.factory()
            obj_.build(child_)
            self.max12 = obj_
            obj_.original_tagname_ = 'max12'
        elif nodeName_ == 'max13':
            obj_ = max13Type.factory()
            obj_.build(child_)
            self.max13 = obj_
            obj_.original_tagname_ = 'max13'
        elif nodeName_ == 'max21':
            obj_ = max21Type.factory()
            obj_.build(child_)
            self.max21 = obj_
            obj_.original_tagname_ = 'max21'
        elif nodeName_ == 'max22':
            obj_ = max22Type.factory()
            obj_.build(child_)
            self.max22 = obj_
            obj_.original_tagname_ = 'max22'
        elif nodeName_ == 'max23':
            obj_ = max23Type.factory()
            obj_.build(child_)
            self.max23 = obj_
            obj_.original_tagname_ = 'max23'
        elif nodeName_ == 'max31':
            obj_ = max31Type.factory()
            obj_.build(child_)
            self.max31 = obj_
            obj_.original_tagname_ = 'max31'
        elif nodeName_ == 'max32':
            obj_ = max32Type.factory()
            obj_.build(child_)
            self.max32 = obj_
            obj_.original_tagname_ = 'max32'
        elif nodeName_ == 'max33':
            obj_ = max33Type.factory()
            obj_.build(child_)
            self.max33 = obj_
            obj_.original_tagname_ = 'max33'
# end class matrixType


class max11Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max11Type.subclass:
            return max11Type.subclass(*args_, **kwargs_)
        else:
            return max11Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max11Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max11Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max11Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max11Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max11Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max11Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max11Type


class max12Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max12Type.subclass:
            return max12Type.subclass(*args_, **kwargs_)
        else:
            return max12Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max12Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max12Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max12Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max12Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max12Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max12Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max12Type


class max13Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max13Type.subclass:
            return max13Type.subclass(*args_, **kwargs_)
        else:
            return max13Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max13Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max13Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max13Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max13Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max13Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max13Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max13Type


class max21Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max21Type.subclass:
            return max21Type.subclass(*args_, **kwargs_)
        else:
            return max21Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max21Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max21Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max21Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max21Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max21Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max21Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max21Type


class max22Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max22Type.subclass:
            return max22Type.subclass(*args_, **kwargs_)
        else:
            return max22Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max22Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max22Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max22Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max22Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max22Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max22Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max22Type


class max23Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max23Type.subclass:
            return max23Type.subclass(*args_, **kwargs_)
        else:
            return max23Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max23Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max23Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max23Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max23Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max23Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max23Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max23Type


class max31Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max31Type.subclass:
            return max31Type.subclass(*args_, **kwargs_)
        else:
            return max31Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max31Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max31Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max31Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max31Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max31Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max31Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max31Type


class max32Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max32Type.subclass:
            return max32Type.subclass(*args_, **kwargs_)
        else:
            return max32Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max32Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max32Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max32Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max32Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max32Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max32Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max32Type


class max33Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord=None):
        self.original_tagname_ = None
        self.coord = _cast(float, coord)
    def factory(*args_, **kwargs_):
        if max33Type.subclass:
            return max33Type.subclass(*args_, **kwargs_)
        else:
            return max33Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coord(self): return self.coord
    def set_coord(self, coord): self.coord = coord
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='max33Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='max33Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='max33Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='max33Type'):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            outfile.write(' coord="%s"' % self.gds_format_float(self.coord, input_name='coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='max33Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='max33Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            showIndent(outfile, level)
            outfile.write('coord=%f,\n' % (self.coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord', node)
        if value is not None and 'coord' not in already_processed:
            already_processed.add('coord')
            try:
                self.coord = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class max33Type


GDSClassesMapping = {
    'dbDetail': dbDetailType,
    'listMapRegion': listMapRegionType,
    'sequence': sequenceType,
    'max31': max31Type,
    'crossRefDb': crossRefDbType,
    'alignObject': alignObjectType,
    'max21': max21Type,
    'residue': residueType,
    'residueDetail': residueDetailType,
    'matrix': matrixType,
    'geo3d': geo3dType,
    'segmentDetail': segmentDetailType,
    'max32': max32Type,
    'listDB': listDBType,
    'max33': max33Type,
    'score': scoreType,
    'max11': max11Type,
    'max12': max12Type,
    'max13': max13Type,
    'entityDetail': entityDetailType,
    'db': dbType2,
    'entity': entityType1,
    'segment': segmentType3,
    'mapRegion': mapRegionType,
    'listResidue': listResidueType,
    'alignObjectDetail': alignObjectDetailType,
    'max23': max23Type,
    'vector': vectorType,
    'max22': max22Type,
    'entryDetail': entryDetailType,
    'block': blockType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'entry'
        rootClass = entry
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'entry'
        rootClass = entry
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    try:
        from io import StringIO
        doc = parsexml_(StringIO(inString))
    except ImportError:
        from io import BytesIO
        doc = parsexml_(BytesIO(inString.encode('utf8')))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'entry'
        rootClass = entry
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'entry'
        rootClass = entry
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from sifts import *\n\n')
        sys.stdout.write('import sifts as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj

__all__ = [
    "Description",
    "RDF",
    "alignObjectDetailType",
    "alignObjectType",
    "alignment",
    "any",
    "blockType",
    "contributor",
    "coverage",
    "creator",
    "crossRefDbType",
    "date",
    "dbDetailType",
    "dbType",
    "dbType2",
    "description",
    "entityDetailType",
    "entityType1",
    "entry",
    "entryDetailType",
    "format",
    "geo3dType",
    "identifier",
    "language",
    "listDBType",
    "listMapRegionType",
    "listResidueType",
    "mapRegionType",
    "matrixType",
    "max11Type",
    "max12Type",
    "max13Type",
    "max21Type",
    "max22Type",
    "max23Type",
    "max31Type",
    "max32Type",
    "max33Type",
    "publisher",
    "relation",
    "residueDetailType",
    "residueType",
    "rights",
    "scoreType",
    "segmentDetailType",
    "segmentType",
    "segmentType3",
    "sequenceType",
    "source",
    "subject",
    "title",
    "type_",
    "vectorType"
]

if __name__ == "__main__":
    import sys
    from Bio.SeqUtils import seq1
    from itertools import product

    s = parseString(sys.stdin.read(), silence=True)
    for e in s.get_entity():
        for seg in e.get_segment():
            for residue in seg.get_listResidue().get_residue():
                for pdb, uniprot in product(filter(lambda x: x.get_dbSource() == 'PDB',
                                            residue.get_crossRefDb()),
                                            filter(lambda x: x.get_dbSource() == 'UniProt',
                                            residue.get_crossRefDb())):
                    print('\t'.join([s.get_dbAccessionId(),
                                    pdb.get_dbChainId(),
                                    seq1(pdb.get_dbResName()),
                                    pdb.get_dbResNum(),
                                    uniprot.get_dbAccessionId(),
                                    uniprot.get_dbResName(),
                                    uniprot.get_dbResNum()]))
